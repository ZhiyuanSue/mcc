read in file name:
	./pre/EBNF.i
            
                  
                  
                    
                      
                  
              
                
                        
                        
                                
                               
typedef long unsigned int size_t;

typedef long int __off64_t;
typedef long int __off_t;

typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;

typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
typedef __fpos_t fpos_t;

typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;

struct _IO_marker;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;

  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;

  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
extern int remove(const char *filename);

extern int rename(const char *old, const char *new);

extern FILE *tmpfile(void);

extern char *tmpnam(char *s);

extern int fclose(FILE *stream);

extern int fflush(FILE *stream);

extern FILE *fopen(const char * restrict filename,
    const char * restrict mode);

extern FILE *freopen(const char * restrict filename,
    const char * restrict mode,
    FILE * restrict stream);

extern void setbuf(FILE * restrict stream,
    char * restrict buf);

extern int setvbuf(FILE * restrict stream,
    char * restrict buf,
    int mode, size_t size);

extern int fprintf(FILE * restrict stream,
    const char * restrict format, ...);

extern int fscanf(FILE * restrict stream,
    const char * restrict format, ...);

extern int printf(const char * restrict format, ...);

extern int scanf(const char * restrict format, ...);

extern int snprintf(char * restrict s, size_t n,
    const char * restrict format, ...);

extern int sprintf(char * restrict s,
    const char * restrict format, ...);

extern int sscanf(const char * restrict s,
    const char * restrict format, ...);

extern char *fgets(char * restrict s, int n,
    FILE * restrict stream);

extern int fputc(int c, FILE *stream);

extern int fputs(const char * restrict s,
    FILE * restrict stream);

extern int getc(FILE *stream);

extern int getchar(void);

extern int putc(int c, FILE *stream);

extern int putchar(int c);

extern int puts(const char *s);

extern int ungetc(int c, FILE *stream);

extern size_t fread(void * restrict ptr,
    size_t size, size_t nmemb,
    FILE * restrict stream);

extern size_t fwrite(const void * restrict ptr,
    size_t size, size_t nmemb,
    FILE * restrict stream);

extern int fgetpos(FILE * restrict stream,
    fpos_t * restrict pos);

extern int fseek(FILE *stream, long int offset, int whence);

extern int fsetpos(FILE *stream, const fpos_t *pos);

extern long int ftell(FILE *stream);

extern void rewind(FILE *stream);

extern void clearerr(FILE *stream);

extern int feof(FILE *stream);

extern int ferror(FILE *stream);

extern void perror(const char *s);

extern int fprintf_s(FILE * restrict stream,
    const char * restrict format, ...);

extern int fscanf_s(FILE * restrict stream,
    const char * restrict format, ...);

extern int printf_s(const char * restrict format, ...);

extern int scanf_s(const char * restrict format, ...);

extern int sscanf_s(const char * restrict s,
    const char * restrict format, ...);
                          

                                 
                                
typedef long unsigned int size_t;

extern void *memset(void *s, int c, size_t n);

extern int strcmp(const char *s1, const char *s2);

extern void *memcpy(void * restrict s1,
    const void * restrict s2, size_t n);
                          

                                 






                                
                               
extern int *__errno_location(void);
                                 
                                 


                                 
                                
                                   
                                  
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;
                                 
    typedef unsigned long int uintptr_t;
                                 


typedef int wchar_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;





typedef long int ptrdiff_t;

typedef struct
{
  int count;
  union
  {
    int wch;
    char wchb[4];
  } value;
} mbstate_t;




extern size_t mbrtoc16 (char16_t *restrict pc16,
                        const char *restrict s, size_t n,
                        mbstate_t *restrict p);


extern size_t c16rtomb (char *restrict s, char16_t c16,
                        mbstate_t *restrict ps);



extern size_t mbrtoc32 (char32_t *restrict pc32,
                        const char *restrict s, size_t n,
                        mbstate_t *restrict p);


extern size_t c32rtomb (char *restrict s, char32_t c32,
                        mbstate_t *restrict ps);
                                 




extern size_t __ctype_get_mb_cur_max (void);

typedef long unsigned int size_t;

extern void *malloc(size_t size);

extern void free(void *ptr);

extern _Noreturn void exit(int status);

extern long int strtol(
    const char * restrict nptr,
    char ** restrict endptr,
    int base);

extern long long int strtoll(
    const char * restrict nptr,
    char ** restrict endptr,
    int base);

extern unsigned long int strtoul(
    const char * restrict nptr,
    char ** restrict endptr,
    int base);

extern unsigned long long int strtoull(
    const char * restrict nptr,
    char ** restrict endptr,
    int base);

extern double strtod(const char * restrict nptr,
    char ** restrict endptr);

extern float strtof(const char * restrict nptr,
    char ** restrict endptr);

extern long double strtold(const char * restrict nptr,
    char ** restrict endptr);

extern int mbtowc(wchar_t *pwc, const char *str, size_t n);

extern int mblen (const char *s, size_t n);
                          

                                  
                          



                                
                          
                        
                         
                        
inline _Bool is_legal_align(unsigned long int align_size)
{
        if (align_size==0)
                return 0;
        while(align_size%2==0)
        {
                align_size/=2;
        }
        if(align_size!=1)
                return 0;
        else
                return 1;
}
                          
                
                     
                    
enum compiler_error{
    C0001_ERR_NONE,C0002_ERR_UNKNOWN,

    C0003_ERR_LEX_ERROR,

    C0004_ERR_NAMESPACE,
    C0005_ERR_REDEFINE,
    C0006_ERR_NOT_IN_SYMBOL_TABLE,
    C0007_ERR_UNEXPECTED_TOKEN,


    C0008_ERR_TOO_MANY_STOR_SPEC,
    C0009_ERR_THREAD_LOCAL_PREFIX,
    C0010_ERR_NEED_MORE_TYPE_SPEC,
    C0011_ERR_WRONG_TYPE_SPEC,
    C0012_ERR_COMPLEX_NOT_SUPPORT,
    C0013_ERR_ATOMIC_UNSUPPORT,
    C0014_ERR_ATOMIC_TYPE_NAME,

    C0015_ERR_REDEFINATION,
    C0016_ERR_UNDECLARATION,
    C0017_ERR_TYPEDEF_OVERLAP,
    C0018_ERR_STRUCT_INCOMPLETE_FUNCTION_TYPE,
    C0019_ERR_ILLEGAL_CONST_EXPR,
    C0020_ERR_CONST_EXPR_RANGE,
    C0021_ERR_STATIC_ASSERT,


    C0022_ERR_BIT_FIELD_TYPE,
    C0023_ERR_BIT_FIELD_WIDTH_EXCEED,
    C0024_ERR_BIT_FIELD_WIDTH_INT,
    C0025_ERR_BIT_FIELD_WIDTH_NEGATIVE,
    C0026_ERR_BIT_FIELD_ZERO_WITH_DECLERATOR,

    C0027_ERR_ENUM_NOT_INT,
    C0028_ERR_ENUM_RANGE,

    C0029_ERR_LKA_EXTERN_FOLLOW_NO,
    C0030_ERR_LKA_NO_FOLLOW_EXTERN,
    C0031_ERR_CONFICT_TYPE,
    C0032_ERR_CONFICT_LINKAGE,
    C0033_ERR_CONFICT_THREAD_LOCAL,

    C0034_ERR_ARR_STAR_SCOPE,
    C0035_ERR_ARR_QUAL_STATIC_OUTMOST,
    C0036_ERR_ARR_QUAL_STATIC_IN_PARA,
    C0037_ERR_ARR_STATIC_THREAD_WITH_VLA,
    C0038_ERR_ARR_SIZE_INTEGER,
    C0039_ERR_ARR_SIZE_ZERO,
    C0040_ERR_ARR_FUNCTIONS_INCOMPLETE,
    C0041_ERR_VM_ID,

    C0042_ERR_FUN_IDENTIFIER_LIST,
    C0043_ERR_FUN_RETURN_TYPE,
    C0044_ERR_FUNC_DEF_DECL_TYPE,
    C0045_ERR_FUNC_PARA_INCOMPLETE_TYPE,
    C0046_ERR_FUNC_VOID_MORE_THAN_ONE,
    C0047_ERR_FUNC_PARA_STORAGE,

    C0048_ERR_LVALUE_ARR_TYPE_COMPLETE,
    C0049_ERR_LVALUE_ARR_TYPE_WRONG,
    C0050_ERR_LVALUE_FUNC_TYPE_WRONG,
    C0051_ERR_LVALUE_REQUIRED,

    C0052_ERR_EXPR_TYPE_ERROR,
    C0053_ERR_EXPR_STRUCT_UNION_DOT_TYPE_WRONG,
    C0054_ERR_EXPR_STRUCT_UNION_POINT_TYPE_WRONG,
    C0055_ERR_EXPR_POSTFIX_DOUBLE_P_M_TYPE,
    C0056_ERR_EXPR_MODIFIABLE_LVALUE,

    C0057_ERR_OPERAND_BIT_FIELD,
    C0058_ERR_OPERAND_REGISTER,
    C0059_ERR_OPERAND_SHOULD_POINTER,

    C0060_ERR_OPERAND_INTEGER_TYPE,
    C0061_ERR_OPERAND_ARTHMATIC_TYPE,
    C0062_ERR_OPERAND_SCALAR_TYPE,
    C0063_ERR_OPERAND_REAL_TYPE,

    C0064_ERR_SIZEOF_INCOMPLETE,
    C0065_ERR_SIZEOF_FUNCTION,

    C0066_ERR_CAST_CONVERT_POINT_FLOAT,
    C0067_ERR_ADD_OPERAND_TYPE,
    C0068_ERR_MINUS_OPERAND_TYPE,
    C0069_ERR_NEED_COMPATIBLE_TYPE,
    C0070_ERR_EQUAL_OPERAND,
    C0071_ERR_CONDITION_OPERAND,
    C0072_ERR_ASSIGN_OPERAND,

    C0073_ERR_FUNC_MORE_PARAMETERS,
    C0074_ERR_FUNC_PARA_TYPE,

    C0075_ERR_FOR_DECLARATION_STOR,
    C0076_ERR_IN_SWITCH,
    C0077_ERR_SWITCH_SAME_CASE,
    C0078_ERR_IN_LOOP,
    C0079_ERR_IN_SWITCH_LOOP,
    C0080_ERR_FUNC_RET_VOID,
    C0081_ERR_FUNC_RET_NONE_VOID,
    C0082_ERR_FUNC_NO_ID_LIST_BUT_DEC,
    C0083_ERR_FUNC_PARA_INITILIZATION,
    C0084_ERR_FUNC_STORAGE,
    C0085_ERR_FUNC_PARA_OLD_NOT_FIND,
    C0086_ERR_FUNC_PARA_OLD_NOT_DEC,
    C0087_ERR_FUNC_PARA_OLD_STOR,
    C0088_ERR_ALIGN_TWO_POWER,
    C0089_ERR_ALIGN_CANNOT_SPECIFIE,
    C0090_ERR_ALIGN_DIFFERENT_DECLARATION,
    C0091_ERR_INIT_TYPE_COMPLETE,
    C0092_ERR_INIT_ENTITY,
    C0093_ERR_INIT_DESIGNATOR_CONST_EXPR,
    C0094_ERR_INIT_DESIGNATOR_IDENTIFIER,

    W0001_WARN_NONE,W0002_WARN_UNKNOWN,
    W0003_WARN_NO_DECLARATION_ANY_THING,
    W0004_WARN_DUPLICATE_QUAL,
    W0005_WARN_IMPLICIT_DEC,
    W0006_WARN_NO_RETURN,
};
typedef unsigned int LINE_NUM;
typedef struct line{
    LINE_NUM line_number;
    size_t start;
    size_t end;
}LINE;
typedef struct mcc_error_item{
    enum compiler_error ce;
    char* filename;
    LINE_NUM error_line;
    char* error_token_value;
}ERROR_ITEM;

void m_error(char filename[],char function[],char reason[]);
void m_error_arg_char(char* arg);
void m_error_arg_int(int arg);

void m_test(char test[]);
void m_test_item(char test_item_name[]);
void m_test_arg_char(char* item_arg);
void m_test_arg_int(int item_arg);

void mcc_error(ERROR_ITEM* e,char* file_buf,LINE* line);
inline void* m_error_item(
    ERROR_ITEM* tei,
    enum compiler_error ce,
    char* filename,
    LINE_NUM error_line,
    char* error_token_value)
{
    tei->ce=ce;
    tei->filename=filename;
    tei->error_line=error_line;
    tei->error_token_value=error_token_value;
    return (void*)tei;
}
                
                  



               
              
typedef struct mem_pool{
    char name[8];



    unsigned long long int malloc_cnt;
    unsigned long long int free_cnt;
    unsigned long long int sys_malloc_cnt;
    unsigned long long int sys_free_cnt;
}MEM_POOL;
              
MEM_POOL* MEMInit(char name[]);





void MEMDel(MEM_POOL* pool);


void* m_alloc(size_t n);
void m_free(void* p);

inline void m_memset(void* p,char value,size_t len)
{
    memset(p,value,len);
}
                  

typedef struct vector{
    void** data;
    size_t capicity;
    size_t len;
}VEC;





VEC* InitVEC(size_t len);
void VECinsert(VEC* v,void* p);
void VECremove(VEC* v,size_t low,size_t high);
void VECpopback(VEC* v);
void VECexpand(VEC* v);
void VECshrink(VEC* v);
void VECcpy(VEC* src,VEC** dst);
inline void VECappend(VEC* src,VEC* dst){
    if(!src||!dst)
        return;
    for(size_t i=0;i<(src->len);++i){
        VECinsert(dst,((src!=0&&i<(src->len))?(src->data[i]):0));
    }
}
void DelVEC(VEC* v);
                
                        
                
                             
                            
enum rule_type_enum{

    child,

    whitespace,KW_auto,KW_break,KW_case,
    KW_char,KW_const,KW_continue,KW_default,
    KW_do,KW_double,KW_else,KW_enum,
    KW_extern,KW_float,KW_for,KW_goto,
    KW_if,KW_inline,KW_int,KW_long,
    KW_register,KW_restrict,KW_return,KW_short,
    KW_signed,KW_sizeof,KW_static,KW_struct,
    KW_switch,KW_type_def,KW_union,KW_unsigned,
    KW_void,KW_volatile,KW_while,KW__Alignas,
    KW__Alignof,KW__Atomic,KW__Bool,KW__Complex,
    KW__Generic,KW__Imaginary,KW__Noreturn,KW__Static_assert,
    KW__Thread_local,KW_asm,KW_asm_volatile,

    identifier,
    integer_constant,
    floating_constant,
    enum_const,
    char_const,
    string,

    left_bracket,right_bracket,left_parenthesis,right_parenthesis,
    left_brace,right_brace,dot,point,
    double_plus,double_minus,ampersand,star,
    plus,minus,tilde,exclamation,
    forward_slash,percent,left_shift,right_shift,
    less_than,greater_than,less_equal,greater_equal,
    double_equal,un_equal,caret,vertical_bar,
    double_ampersand,double_ver_bar,question,colon,
    semi_colon,three_dot,equal,mul_equal,
    forward_equal,percent_equal,plus_equal,minus_equal,
    left_shift_equal,right_shift_equal,ampersand_equal,caret_equal,
    ver_bar_equal,comma,number_sign,double_number_sign,
    less_colon,colon_greater,less_percent,percent_greater,
    percent_colon,double_percent_colon,

    translation_unit,external_decl,function_definition,expression,
    declaration,statement,

    assignment_expr,conditional_expr,
    logical_or_expr,logical_and_expr,inclusive_or_expr,exclusive_or_expr,
    and_expression,equality_expr,relational_expr,shift_expr,
    additive_expr,multi_expr,cast_expr,unary_expr,
    postfix_expr,primary_expression,generic_selection,
    constant_expr,

    declaration_spec,init_decl_list,init_decl,storage_class_spec,
    type_spec,atomic_type_spec,struct_union_spec,struct_union,
    struct_decl_list,struct_decl,spec_qual_list,struct_declarator_list,
    struct_declarator,enum_spec,enum_list,enumerator,enumerator_const,
    type_qual,function_spec,alignment_spec,declarator,
    pointer,direct_declarator,type_qual_list,parameter_type_list,
    parameter_list,parameter_declaration,identifier_list,
    type_name,abstract_declarator,direct_abstract_declarator,type_def_name,
    initializer,initializer_list,designation,designator_list,
    designator,static_assert_declaration,

    labeled_stmt,compound_stmt,expr_stmt,if_stmt,
    switch_stmt,while_stmt,do_stmt,for_stmt,
    goto_stmt,continue_stmt,break_stmt,return_stmt,

    asm_stmt,ASM_extend,
    ASM_output,ASM_input,ASM_register,ASM_restrict,

    end_of_file
};
                




extern char rule_type_str[256][256];

typedef struct base{
    int type;
    char* name;
}BASE;
               
typedef struct statement{
    BASE base;
    char* value;
}STATE;


typedef struct rule{
    BASE base;
    enum rule_type_enum type;
    VEC* rule_value;
    unsigned int rule_index;
}RULE;

char* readin_name(char* buf,int length);
char* readin_value(char* buf);
_Bool is_Match_state(STATE* s,char target);





void* match_name(char* str,int strlen,VEC* v);
VEC* readin_rule_value(char* buf,VEC* source_v,VEC* dest_v,int* type);

VEC* LexInitSTATE(VEC* sv,char statements[256][256]);
VEC* InitRULE(VEC* sv,VEC* rv,char rules[1024][256]);

void test_statement(VEC* sv);
void test_rule(VEC* sv,VEC* rv);
              
VEC* LexInitSTATE(VEC* sv,char statements[256][256]){
    sv=InitVEC(3);

    char buf[256];
    for(int i=0;i<256;++i){
        m_memset(buf,'\0',256);
        memcpy(buf,statements[i],256);
        if((*buf)=='\0')
            continue;
        STATE* tmps=(struct statement*)m_alloc(sizeof(struct statement));
        char* p=buf;
        while((*p)!=':'){ p++; }
        if((*(p+2))=='-')
            tmps->base.type=1;
        else
            tmps->base.type=0;
        tmps->base.name=readin_name((char*)&buf,p-buf);
        tmps->value=readin_value((p+1));
        VECinsert(sv,(void*)tmps);
    }






    return sv;
}
VEC* InitRULE(VEC* sv,VEC* rv,char rules[1024][256]){
    rv=InitVEC(3);

    char buf[256];
    unsigned int rule_index=0;
    for(int i=0;i<1024;++i){
        m_memset(buf,'\0',256);
        memcpy(buf,rules[i],256);
        if((*buf)=='\0')
            continue;
        RULE* tmpr=(RULE*)m_alloc(sizeof(struct rule));
        if(tmpr==0){
            m_error("EBNF.c","InitRULE","m_alloc_error");
            exit(1);
        }
        char* p=buf;
        while((*p)!=':'){ p++; }
        tmpr->base.name=readin_name((char*)&buf,p-buf);
        int index;
        int match_succ=-1;
        for(index=0;index<256;++index){
            if(strcmp(rule_type_str[index],tmpr->base.name)==0)
            {
                match_succ=0;
                break;
            }
        }
        if(match_succ==-1)
            tmpr->type=0;
        else
            tmpr->type=(enum rule_type_enum)index;
        tmpr->rule_index=rule_index;
        rule_index++;
        VECinsert(rv,(void*)tmpr);
    }
    RULE* tmpr;
    for(int i=0;i<(rv->len);++i){
        m_memset(buf,'\0',256);
        memcpy(buf,rules[i],256);
        char* p=buf;
        while((*p)!=':'){ p++; }
        tmpr=(RULE*)((rv!=0&&i<(rv->len))?(rv->data[i]):0);
        if(tmpr==0){
            m_error("EBNF.c","InitRULE","vector error");
            exit(1);
        }
        tmpr->rule_value=readin_rule_value((p+1),sv,rv,&tmpr->base.type);
    }





    return rv;
}
char* readin_name(char* buf,int length){
    char* res;
    res=(char*)m_alloc(sizeof(char)*(length+1));
    memcpy(res,buf,length*sizeof(char));
    res[length]='\0';
    return res;
}
char* readin_value(char* buf){
    char* res;
    if((*(buf+1))=='-'){
        res=(char*)m_alloc(sizeof(char)*3);
        (*res)=(*buf);
        (*(res+1))=(*(buf+2));
        (*(res+2))='\0';
    }
    else{
        char tmp[8193/2];
        m_memset(tmp,'\0',8193/2);
        char* p=buf;
        int plen=0;
        while((*p)!='\0'){
            tmp[plen]=(*p);
            plen++;
            p++;
        }
        res=(char*)m_alloc(sizeof(char)*(plen+1));
        memcpy(res,&tmp,plen+1);
    }
    return res;
}
_Bool is_Match_state(STATE* s,char target){
    if(s->base.type==0){
        int i=0;
        while(s->value[i]!='\0'){
            if(s->value[i]==target)
                return 1;
            i++;
        }
        return 0;
    }
    else if(s->base.type==1){
        if(target>=s->value[0]&&target<=s->value[1]){
            return 1;
        }
        else
            return 0;
    }
    else
        return 0;
}
void* match_name(char* str,int strlen,VEC* v){
    BASE* q;
    if(strlen==-1){
        for(size_t i=0;i<(v->len);++i){
            q=(BASE*)((v!=0&&i<(v->len))?(v->data[i]):0);
            if(strcmp(q->name,str)==0)
                return q;
        }
    }
    else{
        for(size_t i=0;i<(v->len);++i){
            q=(BASE*)((v!=0&&i<(v->len))?(v->data[i]):0);
            _Bool match=1;
            int p=0;
            while(q->name[p]!='\0'&&p<=strlen){
                if(q->name[p]!=str[p])
                {
                    match=0;
                    break;
                }
                p++;
            }
            if(p<strlen)
                match=0;
            if(match){
                return q;
            }
        }
    }

    return 0;
}

VEC* readin_rule_value(char* buf,VEC* source_v,VEC* dest_v,int* type)
{
    char* p=buf;
    char* start;
    *type=-1;
    VEC* rule_value=InitVEC(3);
    while((*p)!='\0'){
        switch (*p){
            case '$':
                start=p+2;
                p=start;
                while((*p)!='}'){
                    p++;
                }
                void* tmps=match_name(start,p-start,source_v);
                if(tmps==0)
                {
                    m_error("EBNF.c","readin_rule_value","illegal input:need more state:");
                    m_error_arg_char(start);
                    exit(1);
                }
                VECinsert(rule_value,tmps);
                break;
            case '&':
                start=p+2;
                p=start;
                while((*p)!='}'){
                    p++;
                }
                void* tmpd=match_name(start,p-start,dest_v);
                if(tmpd==0)
                {
                    m_error("EBNF.c","readin_rule_value","illegal input:need more rule:");
                    m_error_arg_char(buf);
                    exit(1);
                }
                VECinsert(rule_value,tmpd);
                break;
            case '|':
                *type=3;
                break;
            case '*':
                *type=4;
                break;
            case '\?':
                *type=5;
                break;
            default:
                goto final;
                break;
        }
        p++;
    }
final:
    if(*type==-1){
        *type=2;
    }
    return rule_value;
}
void test_statement(VEC* sv){
    m_test("statement table");
    STATE* tsts;
    for(int i=0;i<(sv->len);++i){
        tsts=(STATE*)((sv!=0&&i<(sv->len))?(sv->data[i]):0);
        m_test_item("state");
        m_test_arg_char(tsts->base.name);
        m_test_item("value");
        m_test_arg_char(tsts->value);
    }
}
void test_rule(VEC* sv,VEC* rv){
    m_test("rule table");
    RULE* tstr;
    size_t max_child=0;
    int index=-1;
    for(int i=0;i<(rv->len);++i){
        tstr=(RULE*)((rv!=0&&i<(rv->len))?(rv->data[i]):0);
        m_test_item("rule");
        m_test_arg_char(tstr->base.name);
        m_test_item("rule_type");
        if(tstr->base.type==2)
            m_test_arg_char("link");
        else if(tstr->base.type==3)
            m_test_arg_char("or");
        else if(tstr->base.type==4)
            m_test_arg_char("star");
        else if(tstr->base.type==5)
            m_test_arg_char("question");
        else{
            m_error("EBNF.c","InitRE","undefined type");
            m_test_arg_int(tstr->base.type);
        }
        m_test_item("rule_type");
        m_test_arg_int(tstr->type);
        m_test_item("rule_arguments");
        if(tstr->base.type==2)
        {
            if(((tstr->rule_value)->len)>max_child){
                max_child=((tstr->rule_value)->len);
                index=i;
            }
        }
        for(size_t i=0;i<((tstr->rule_value)->len);++i){
            void* tstv=(((tstr->rule_value)!=0&&i<((tstr->rule_value)->len))?((tstr->rule_value)->data[i]):0);
            int* tstp=(int*)tstv;
            if(*tstp==0||*tstp==1){
                m_test_item("\t#state");
                STATE* tstt=(STATE*)tstv;
                m_test_arg_char(tstt->base.name);
            }
            else{
                m_test_item("\t#rule");
                RULE* tstt=(RULE*)tstv;
                m_test_arg_char(tstt->base.name);
            }
        }
    }
    printf("max child len is %lu,index is %d\n",max_child,index);
}

lex error number:3
error
Compile Error:(file (null): line 881: token ' )
            case '$':
reason:	C0003:Invalid lexical element
Compile Error:(file (null): line 881: token (null) )
            case '$':
reason:	C0003:Invalid lexical element
Compile Error:(file (null): line 881: token ': )
            case '$':
reason:	C0003:Invalid lexical element
