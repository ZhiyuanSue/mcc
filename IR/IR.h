#ifndef _IR_H_
#define _IR_H_
#include "../tools/vector.h"
#include "../tools/list.h"
#include "../tools/symbol_table.h"
#include "IR_ENUM.h"
struct IR_OPERAND_REG{
    enum data_type d_type;
    size_t reg_id;
    IR_INS* ins;    /*as a reg must be generated by an instruction*/
    size_t data_length; /*this data_length use byte, for Type_size use byte*/
    struct{
        enum data_storage_type pointer_data_stor_type;
        signed long int off;    /*the offset from which basement*/
    }pointer_attr;
};
typedef struct operand{
    enum operand_type type;
    union{
        struct IR_OPERAND_DATA{
            enum data_storage_type data_stor_type;
            size_t data_length;
            size_t data_align;
        }operand_data_type;
        struct IR_OPERAND_IMM{
            enum TP_CATEGORY imm_type;
            union{  /*for the int type can cast without any accuracy loss*/
                signed long long int imm_int_data;
                float imm_float_data;
                double imm_double_data;
                long double imm_long_double_data;
            };
        }operand_imm_type;
        struct IR_OPERAND_CODE{
            IR_BB* code_position;   /*it must point to a label position*/
        }operand_code_type;
        IR_REG* operand_reg_type;
    }operand_data;
}IR_OPERAND;

typedef struct instruction{
    LIST_NODE node;
    enum ins_op op;
    IR_OPERAND* dst;
    IR_OPERAND* src1;
    IR_OPERAND* src2;
    IR_MODULE* IR_module;
    IR_FUNC* func;
    IR_BB* block;
    void* other_attr;
}IR_INS;
typedef union cmp_cond{
    enum IR_OP_ICMP_COND icmp_cond;
    enum IR_OP_FCMP_COND fcmp_cond;
}CMP_COND_ATTR;
IR_REG* GenREG(
    enum data_type type,
    VEC* reg_list,
    IR_INS* ins,
    size_t data_length
);
bool GenREGPointerType(
    IR_REG* reg,
    VEC* type_vec
);
bool GenINS(
    IR_INS* ins,
    enum ins_op op,
    IR_OPERAND* dst,
    IR_OPERAND* src1,
    IR_OPERAND* src2);   /*use add_new_ins to get a new one and fill in the data*/
IR_OPERAND* GenOPERAND_DATA(
    enum data_storage_type data_stor_type,
    size_t data_length,
    size_t data_align
);
IR_OPERAND* GenOPERAND_IMM(
    enum TP_CATEGORY imm_type,
    signed long long int imm_int_data,
    float imm_float_data,
    double imm_double_data,
    long double imm_long_double_data
);
IR_OPERAND* GenOPERAND_CODE(
    IR_BB* code_position
);
IR_OPERAND* GenOPERAND_REG(
    IR_REG* operand_reg
);
typedef struct module{
    VEC* func_list;
    VEC* static_stor_symbols;
    VEC* reg_list;
    VEC* bind_reg_list;
}IR_MODULE;
typedef struct function{
    char* func_name;
    VEC* register_list;
    IR_MODULE* IR_module;
    LIST_NODE* BB_list;
    SYM* symbol_table;
}IR_FUNC;
typedef struct basic_block{
    LIST_NODE node;
    char* bb_label;
    IR_MODULE* IR_module;
    IR_FUNC* func;
    LIST_NODE* Instruction_list;
}IR_BB;

IR_FUNC* add_new_func(IR_MODULE* irm);
IR_BB* add_new_bb(IR_FUNC* func);
IR_INS* add_new_ins(IR_BB* bb);

char* label_allocator(char* default_name);    /*allocate a label name for a bb*/

void print_IR(IR_MODULE* irm);
void print_INS(IR_INS* ins,size_t indentation);
#endif