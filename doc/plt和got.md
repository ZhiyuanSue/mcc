本文档主要是对动态链接中的plt和got进行一个描述和记录（Linux版本的）

如有错误，欢迎指正。

## plt

plt表是一堆代码的表项，其中第一项是公共表项，剩下的表项，程序每个可能动态链接到的函数各自占有一项。plt表是代码段的内容，不会被修改。

其代码可以简单的描述为：

```
plt[0]:
	pushl got[1]		//将map表首地址压入栈
	jmp *got[2]		//	跳转到解析函数，根据map表给出对应的函数地址
plt[n]:		//n>=1
	jmp *got[n+2]		//	前三项是公共项
	push (n-1)*8		//	这个值表示了该函数的id（怎么来的一会儿说）
	jmp plt[0]
```

## got

got表是一堆数据，我个人认为更确切的说法是一堆指针组成的向量。got表前三项是特殊表项，分别是

```
got[0]=.dynamic段地址

got[1]=本镜像的link_map地址，我个人理解，是用于后面的_dl_runtime_resolve函数用于解析符号映射到地址的映射表（不一定对）

got[2]=_dl_runtime_resolve函数地址，解析具体的映射的函数，输入某个函数对应的id值（不是具体的符号名称，这个值怎么来等会说），输出则是函数对应的动态链接入口地址

got[n+2](n>=1)则填充着plt[n]对应的第二条指令的地址指针（原因一会儿再说）
```

进程使用的动态链接函数，该函数在当前镜像中的id，plt的表项，got的表项，都是分别一一对应的关系（只不过，plt偏移1，got偏移了3）

其中got[1]和got[2]在编译的时候是不知道的，所以编译器直接填0，由动态链接器填充进去

## 链接时

对每个函数分配一个id，在plt的push，link map中用的都是这个，查找的时候，_dl_runtime_resolve直接根据这个值去找，那么无需再比较符号。

由于编译过程的链接器（修改了plt里面的push的那个值）和运行时的动态链接器（_dl_runtime_resolve查找使用的link_map）采用的都是同样的id，所以对同一份elf镜像文件，找到的一定是相同的函数。

换而言之，这个id仅仅在这份镜像以及对应的进程中是起作用的。

got的首地址被写入elf镜像文件的.dynamic段中，在加载时起作用，也就是got[0]

## 装载后运行前动态链接器

在装载入elf镜像之后，正式跑这段代码之前，动态链接器做了一些事情。

plt属于该镜像的代码段，不用改变。而got表则有一些变化，填入了got[1]和got[2]的内容，这个内容是每个镜像各自持有的，所以不会弄混淆。

## 运行时重定位/动态链接装入和执行过程

运行时重定位主要的思想是，并不是在镜像运行之前就准备好所有动态链接库函数，而是跑到哪里需要用了，再进行载入。

因此，这个运行时重定位需要分为两个部分来讲解。

一个是在代码没装入进去的时候，此时要做的事情是，将代码装到内存某个位置（因为是动态链接嘛，所以位置不确定的），然后把这个装入的地址，存放到对应的got表中，替换掉原来的表项。

另一个是代码已经装入了某个位置的时候。这个时候事情变得简单了，直接使用plt对应表项找到对应的got表的位置，正如第一个阶段所说的，里面就是对应函数的地址。

这里必须从为什么got表项的初始值指向第二条指令开始说。

```
plt[n]:										got
jmp *got[n+2]		------>		plt[n]+1
push (n-1)*8		<-----------|
jmp plt[0]	------------> 调用_dl_runtime_resolve
```

在初始情况下，plt去找got[n+2]指针指向的位置，此时就是jmp的下一条指令，压入函数的id（作为_dl_runtime_resolve的参数），随后运行到plt[0]那里进行解析。

解析过程中，把got[n+2]的内容给改了，并跳转执行对应的函数去了。

而如果got表中的内容已经修改了（也就是目标函数已经装入了，第二次或者往后的调用该函数），那么直接jmp got[n+2]所指向的地址跳转执行就可以了。

这是一个非常巧妙的设计。请细细体会。

